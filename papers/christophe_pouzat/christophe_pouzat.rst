:author: Christophe Pouzat
:email: christophe.pouzat@parisdescartes.fr
:institution: MAP5 lab., Paris-Descartes University and CNRS, Paris, France

:author: Georgios Is. Detorakis
:email: georgios.detorakis@lss.supelec.fr
:institution: LSS, Sup√©lec, Gif-sur-Yvette, France

------------------------------------------------
SPySort: Neuronal Spike Sorting with Python
------------------------------------------------

.. class:: abstract

   Extracellular recordings with multi-electrode arrays is one of the basic tools of contemporary neuroscience. 
   These recordings are mostly used to monitor the activities, understood as sequences of emitted action potentials,
   of *many* individual neurons. But the raw data produced by extracellular recordings are most commonly 
   a *mixture* of activities from several neurons. In order to get the activities of the individual contributing 
   neurons, a pre-processing step called *spike sorting* is required. We present here a pure Python implementation
   of a well tested spike sorting procedure. The latter was designed in a modular way in order to favour a smooth 
   transition from an interactive sorting, for instance with IPython, to an automatic one. Surprisingly enough |---| or sadly enough, 
   depending on one's view point |---| , recoding our now 15 years old procedure into Python was the occasion of 
   major methodological improvements.   
   
.. class:: keywords

   clustering, sampling theorem, sampling jitter correction, dimension reduction, E-M algorithm, Gaussian Mixture Model, kmeans.

Introduction
------------

The role of neuronal synchronisation in the information processing performed by (actual) neuronal networks is an actively debated question in neuroscience. Direct experimental measurement of synchronisation requires the recording of the activities of "as many neurons as possible" with a fine time resolution. In this context, `multi-electrode arrays <http://en.wikipedia.org/wiki/Multi-electrode_array>`_ (MEA) recordings constitute nowadays the technique of choice. The electrodes making an MEA are located in the extracellular space and can thereby record the action potentials or *spikes* emitted by many neurons in their vicinity |---| an analogy is provided by a microphone for an electrode and many static people talking all at once in a language unknown to us for the neurons. Electrophysiologists can therefore monitor many neurons with a "limited" tissue damage |---| the more electrodes are pushed into a tissue, the more damage ensues: a very attractive feature of the methodology. However this attractive feature of multiple neurons recordings comes at a price: since many neurons are recorded from a single electrode, the raw data are a *mixture* (of single neuron activities) and a *comprehensive* use of the data requires the separation of this mixture into its individual components. This "separation" step is what is referred to as *spike sorting* in neurophysiology.

Extracellular recordings have been used for a long time (60 years at least) and it is not surprising that many *spike sorting* procedures have appeared in the literature (see [Ein12]_ for a recent review). Extracellular recordings are also used daily in an applied context when neurologists perform `electromyography <http://en.wikipedia.org/wiki/Electromyography>`_ |---| extracellular recording from skeletal muscles where the *recorded* action potentials are generated by the muscular cells, not by neurons |---| giving data and data analysis problems very similar to the ones we have presented so far. Very similar spike sorting methods have been developed in the former context (*e.g.*, [McG85]_) but scientists working in the different contexts ("neurons" and "muscles") do not seem to be aware that they have colleagues doing the same thing on slightly different data! We present here a rather "simple" approach (in the realm of the existing ones) which is the one we have used most often in the last 15 years. This approach was published in 2002 [Pou02]_ and was successively "incarnated" using IGOR Pro (`Wavemetrics <http://www.wavemetrics.com/>`_), `Scilab <http://www.scilab.org/fr>`_, MATLAB (`MathWorks <http://www.mathworks.fr/products/matlab/>`_), `R <http://www.r-project.org/>`_ and now `Python <https://www.python.org/>`_. This work which was initially planed as a recoding of our present R code into Python was also the occasion to re-think some of the key steps of our procedure. This lead to a major improvement (also back ported to our R code) in the way a specific step, the *sampling jitter estimation and correction*, is performed. This new development is given due space in section :ref:`jitter-estimation` of the present manuscript.

This contribution is written with two generic readers in mind: scientific python users and neurophysiologists doing spike sorting. For the first "reader" we present another example of an actual scientific data analysis problem that is easily handled within the scientific Python ecosystem. The second reader is likely to perform spike sorting with a commercial software provided by one of the MEA amplifiers manufacturers. We do not want to claim that these software are necessarily bad, but it is our experience that when we deal with data sets from different preparations, it is extremely useful to be able to *adapt* our method to the specific features of the data. For instance, when switching from the first olfactory relay of a locust (*Schistocerca americana*) to the first olfactory relay of a cockroach (*Periplaneta americana*) |---| they have many different features [Cha07]_, we will start in a interactive mode, say with IPython, using the method previously developed for the locust, try out some alternative approaches at the key steps (spike detection, dimension reduction, clustering) before settling on a new procedure involving only few experiment specific parameters. The nature of the Python environment providing interactive development and leading to "black box" procedures is a clear advantage here. Doing this kind of method adaptation is hard, not to say impossible, with commercial solutions implementing a "one size fits all" approach. It moreover turns out that it is, nowadays, not that hard to implement the full sequence of steps required for spike sorting thanks to environments like Python that are both user friendly and computationally efficient. So we hope to motivate our second reader to give a try to open solutions giving access to "what's going on under the hood". In addition we are advocates of the *reproducible research* paradigm ([Sto14]_ , [Del12]_) and an implementation of the latter requires accessibility of the code used for a published analysis.   

Two versions of the source code are available. A "simple" one associated with a step-by-step tutorial 
`http://xtof.perso.math.cnrs.fr/locust_sorting_python.html <http://xtof.perso.math.cnrs.fr/locust_sorting_python.html>`_, the source file (in emacs org mode) necessary to produce an extended version of the present document is available at the following address: 
`http://xtof.perso.math.cnrs.fr/org/PouzatDetorakis2014.org <http://xtof.perso.math.cnrs.fr/org/PouzatDetorakis2014.org>`_. An object-oriented implementation of the method is available on Github:
`https://github.com/gdetor/SPySort <https://github.com/gdetor/SPySort>`_. The
present methodological developments will be soon merged with `OpenElectrophy <https://github.com/OpenElectrophy/OpenElectrophy>`_.


Data properties
---------------

The data used for illustration here were recorded from the first olfactory relay, *the antennal lobe*, of a locust (*Schistocerca americana*). Recording setting and acquisition details are described in [Pou02]_. The data are available and can be dowloaded with:: 
   
   from urllib.request import urlretrieve
   data_names = ['Locust_' + str(i) + '.dat.gz'
                 for i in range(1,5)]
   data_src = ['http://xtof.disque.math.cnrs.fr/data/'
               + n for n in data_names]
   [urlretrieve(data_src[i],data_names[i])
    for i in range(4)]

They were stored as floats coded on 64 bits and compressed with gnuzip. 20 seconds of data sampled at 15 kHz are contained in these files. Four files corresponding to the four electrodes or recording sites of a *tetrode* (see Sec. :ref:`why-tetrode`) are used. The first second of data from the four recording sites is shown next (Figure :ref:`FirstSecondFig`).

.. figure:: Fig1.png
   :scale: 75%
   :figclass: hbt

   First second of data recorded from the four recording sites of a tetrode. :label:`FirstSecondFig`

Here, the action potentials or spikes are the sharp (upward and downward) deviations standing out of the "noise". When doing spike sorting we try to find *how many different neurons* contribute to the data and, for each spike, what is the (most likely) neuron that generated it.

.. _why-tetrode:

Why tetrode?
^^^^^^^^^^^^

The main parameter controlling the amplitude of a recorded spike is the distance between the neuron and the electrode. It follows that if two similar neurons are equidistant to a given electrode, they will give rise to nearly identical spikes |---| for an elaboration on that and on how the signals recorded on different electrodes could be use to perform source localisation, see [Che05]_. These (nearly) identical recorded spikes are a big problem since the spike waveform (combination of shape and amplitude) is going to be our classification criterion. In some preparation, like the locust antennal lobe (but not the cockroach antennal lobe) using tetrodes, groups of four closely spaced electrodes, is going to help us as illustrated in figure :ref:`WhyTetrodesFig`.

.. figure:: Fig2.png
   :scale: 75%
   :figclass: htb

   100 ms of data from the four recording sites of a tetrode. Four clear spikes on
   the fourth recording site are marked by coloured arrows. :label:`WhyTetrodesFig`

Imagine here that only the lowest electrode is available. Given the noise level, it would be hard to decide if the four spikes (arrows in figure :ref:`WhyTetrodesFig`) are originating from the same neuron or not. If we now look at the same events from the additional viewpoints provided by the other electrodes (the three upper traces) it is clear that the four events cannot arise from the same neuron: the first and fourth events (seen on the lowest trace) are large on the four electrodes, while the second and third are large on the top and bottom traces but very tiny on the two middle traces.


Main modelling assumptions
--------------------------
 
We will simplify the neurons discharge statistics by modelling them as independent Poisson processes |---| the successive inter spike intervals (ISI) of a given neuron are independently and identically distributed following an exponential distribution, they are also independent of the ISI of the other neurons. *This is obviously a gross simplification*: we know that the ISI of a given neuron are not Poisson distributed and that the discharges of different neurons are correlated |---| that is precisely *what we want to study with these experiments* |---| but the deviations of the actual data generation mechanism from our simple model (independent Poisson processes) has, in general, a negligible impact on the sorting results. If we want to work with more realistic models, we can (although not yet in Python), but the computational price is rather heavy ([Pou04]_ and [Del06]_). We do go even further on the simplification path for these data since we are going to "forget" about the different discharge rates (at the classification stage, Sec. :ref:`peeling`) and use only the amplitude information.

When a neuron fires a spike *the same underlying waveform* with some additive auto-correlated Gaussian noise is recorded on each site (more precisely there is one waveform per electrode and per neuron). Four comments:

* For some data sets (*e.g.*, [Del06]_) the underlying waveform of a given neuron is changing during the discharge; we can model that if necessary ([Pou04]_ and [Del06]_), but the computational cost is high and the neurons of the data set considered here do not exhibit this feature.
* Following [Che05]_ we could simplify the model assuming that we have a single "mother" waveform per neuron and that the underlying waveform seen on each electrode are just *scaled* versions of the mother waveform. We haven't implemented this feature yet but it will come next.
* Some authors [Sho03]_ argue that the additive noise would be better described by a multivariate t-distribution; they are lead to this assumption because they do not resolve superposed events |---| when two or more neurons fire at nearly the same time the observed event is a "superposition": the sum of the underlying waveforms of the different neurons plus noise. If superpositions are resolved, the Gaussian noise assumption is perfectly reasonable [Pou02]_.     
* The noise is necessarily auto-correlated since the data are low-pass filtered prior to digitisation.

.. _sorting-procedure:

The sorting procedure
---------------------

A very detailed, "step-by-step", account of the analysis presented here can be found on our dedicated web page (`<http://xtof.perso.math.cnrs.fr/locust_sorting_python.html>`_). For most of the steps only a brief description is given in order to save space for the original part. We moreover focus on the first part of the analysis of what is typically a large data set. Experimentalists usually record for hours if not days [Cha07]_ from the same preparation. In our experience such recordings are stable on a time scale of 10 minutes or more. It therefore makes perfect sense to split the analysis in two parts:

1. Model estimation: in the "easy" settings as here, a model boils down to a catalogue of waveforms, one waveform per neuron and per recording site. More sophisticated models can be used but the case illustrated here |---| and *that is not a rare case* |---| they are not necessary.
2. Once the model / waveform catalogue has been obtained the data are processed; that is events are detected and classification is performed by template matching |---| the catalogue's waveforms being the templates.

The key point is that part 1 can be done on a short data stretch |---| in the example bellow we are going to use 10 seconds of data. This part is also the one that can require the largest amount of user input, in particular when a choice on the number of neurons to include in the model has to be made. The second part is straightforward to automate: a short Python script loading, say, 2 minutes of data and the catalogue will do the template matching as illustrated in Sec. :ref:`peeling`. A "poor's man" illustration of this 2 parts approach is provided here since the model is estimated on the first half of the data set and the classification is performed on the whole set. When applying this approach, one should monitor the number of unclassified events over a given time period and *update the model* if this number increases suddenly.  

.. _data-normalisation:

Data normalisation
^^^^^^^^^^^^^^^^^^

If the data have not been high-passed filtered prior to digitization, they are so filtered (with a cutoff frequency between 200 and 500 Hz) using function ``firwin`` of module `scipy.signal <http://docs.scipy.org/doc/scipy/reference/tutorial/signal.html#fir-filter>`_.
The trace of each electrode is then `median <http://en.wikipedia.org/wiki/Median>`_ subtracted and divided by its `median absolute deviation <http://en.wikipedia.org/wiki/Median_absolute_deviation>`_ (MAD). The MAD provides a robust estimate of the standard deviation *of the recording noise*. After this normalisation, detection thresholds are comparable on the different electrode.

.. _spike-detection:

Spike detection
^^^^^^^^^^^^^^^
Spikes are detected as local extrema above a threshold. More precisely, the data are first filtered with a box filter (a moving average) in order to reduce the high frequency noise; the filtered data are normalised like the raw data before being "rectified": amplitudes below a threshold are set to zero; the filtered and rectified data from each electrode are added together and local maxima are identified. This is a very simple method that works well for these data. This is clearly an important step that must typically be adapted to the data one works with. For instance when the signal to noise ratio is lower, we often construct a "typical waveform" |---| by detecting the largest events first, averaging and normalising them (peak at 1 and mean at 0) |---| that we convolve with the raw data. The detection is subsequently done on these filtered data. Working with an environment like Python we can do that with a few lines of code, try different ideas and different parameters, etc.

.. _sample-construction:
 
Events set (sample) construction
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
After a satisfying detection has been obtained, events are "cut" from the raw data. An optimal cut length is obtained by first using overly large cuts (say 80 sampling points on both sides of the detected peak). The point-wise MAD is computed and the locations at which the MAD reaches 1 (the noise level on the normalised traces) give the domain within which "useful sorting information" is to be found. New shorter cuts are then made (in the illustrated case, Fig.  :ref:`First200Fig`, using 14 points before the peak and 30 points after) and an event is then described by a set of N amplitudes on 4 electrodes (in our case 180 amplitudes). The first 200 events are shown in Figure :ref:`First200Fig`.

.. figure:: Fig3.png
   :scale: 60%
   :figclass: hbt

   First 200 events: Black, non-superposed events; red, superpositions. The cuts are 3 ms (45 sampling points) long. Identical scales on each sub-plot. :label:`First200Fig`

Superpositions (*i.e.*, two or more spikes fired at nearly the same time by two or more neurons) are clearly visible as secondary peaks on each recording site (red in figure :ref:`First200Fig`).
    
.. _dimension-reduction:
 
Dimension reduction 
^^^^^^^^^^^^^^^^^^^

The cuts shown in Fig. :ref:`First200Fig` are 3 ms or 45 sampling points long. That means that our sample space has 45x4 = 180 dimensions. Our model assumptions imply that, in the absence of recording noise, each neuron would generate a single point in this space |---| strictly speaking, because of the sampling jitter (see Sec. :ref:`jitter-estimation`), each neuron would generate a small cloud |---| and the recording noise will transform these "centers" into clouds, each cloud having the same variance-covariance matrix |---| this is of course expected only for the events that are not superpositions. At that stage sorting reduces to a `clustering <http://scikit-learn.org/stable/modules/clustering.html#clustering>`_ problem and doing clustering in a 180 dimensional space is rarely a good idea. We therefore reduce the dimension of our events' space using principal component analysis (PCA) keeping only a few of the first principal components. But before that, the "most obvious" superpositions are removed from the sample. We do that because a few superpositions can dominate (and strongly corrupt) the result of a PCA analysis. The goal of this initial part of our procedure is moreover to build a catalogue of underlying waveform associated with each neuron. The actual sorting will be subsequently accounting for superpositions when they occur. The "most obvious superpositions" are removed by looking for side peaks on each individual event. Figure :ref:`ScatMatFig` (made with ``scatter_matrix`` of `pandas <http://pandas.pydata.org/>`_) shows the events projected on the planes defined by every pair of the first four principal components. 

.. figure:: Fig4.png
   :scale: 75%
   :figclass: hbt

   Scatter plot matrices of the events that are not superpositions on the plans defined by every pair of the first four principal components. :label:`ScatMatFig`

We get an upper bound on the number of components to keep by building figures like Fig. :ref:`ScatMatFig` with higher order components until the projected data look featureless (like a two dimensional Gaussian). We get an idea of the number of neurons by counting the number of clouds on the "good" projections (looking at the plot on row 1 and column 2 in Fig. :ref:`ScatMatFig` we see 10 clouds).
  
.. _dynamic-visualisation:

Dynamic visualisation
^^^^^^^^^^^^^^^^^^^^^

At that stage, dynamic visualisation can help a lot. We therefore typically export in ``csv`` format the data projected on the sub-space defined by principal components up to the upper bound found as just described. We then visualise the data with the free software `GGobi <http://www.ggobi.org/>`_. The latter is extremely useful to: reduce further the dimension of the sub-space used; refine the initial guess on the number of clouds; evaluate the clouds shape (which conditions the clustering algorithm used).

.. _clustering-kmeans:
  
Clustering
^^^^^^^^^^

Although most of the spike sorting literature focuses on clustering methods, in our experience standard, well known and thoroughly tested methods work fine. After observing the data as in Fig. :ref:`ScatMatFig` and with GGobi, we can decide what method should be used: a "simple" K-Means; a Gaussian mixture model (GMM) fitted with an E-M algorithm |---| both implemented in `scikit-learn <http://scikit-learn.org/stable/>`_ |---|; bagged-clustering [Lei99]_ that we implemented in Python. For the data analysed here, we see 10 well separated clusters (clouds) that have uniform (spherical) shapes, suggesting that the K-Means are going to work well. 

Figure :ref:`FirstTwoClusters` shows the events attributed to the first 2 clusters. In order to facilitate model comparison (when models with different numbers of neurons are used or when a K-Means fit is compared with a GMM fit), clusters are ordered according to their centers' sizes. That is, for each cluster the point-wise median is computed and its size, the sum of its absolute values (an L1 norm), is obtained.

.. figure:: Fig5.png
   :scale: 60%
   :figclass: hbt

   Left: the 52 events attributed to cluster 0. Right: the 65 events attributed to cluster 1. In red, the point-wise MAD (robust estimate of the standard deviation) :label:`FirstTwoClusters`.

The point-wise MAD has been added to the events as a red trace in Fig. :ref:`FirstTwoClusters`. If the reader remembers our modelling assumptions he or she will see a problem with the MAD of the second cluster (right column) on the top electrode: the MAD is clearly increasing on the rising phase of the event while our hypothesis imply that the MAD should be flat. But this MAD increase is obviously due to bad events' alignment. Seeing this kind of data, before rejecting our model hypothesis, we should try to better align the events to see if that could solve the problem. This is what we are going to do in the next section.    

.. _jitter-estimation:

Jitter estimation and cancellation
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
The "misaligned" events of Fig. :ref:`FirstTwoClusters` (top right) have two origins. First, even in the absence of recording noise, we would have a jitter since the clock of our A/D card cannot be synchronised with the "clocks" of the neurons we are recording. This implies that when we are repetitively sampling spikes from a given neuron, the delay between the actual spike's peak and its closest sampling time *will fluctuate* (in principle uniformly between -1/2 and +1/2 a sampling period). Since we are working with the sampled versions of the spikes and are aligning them on their apparent peaks, we are introducing a distortion or a *sampling jitter* [Pou02]_. In addition, and that's the second origin of the misaligned events, we definitely have some recording noise present in the data and because of this noise we are going to make mistakes when we detect our local maxima at the very beginning of our procedure. In other words we would like to find local maxima of the ``signal`` but we can't do better (at that stage) than finding the local maxima of the ``signal + noise``. Having a clear idea of the origin of the misalignment, we could decide that the MAD increase is not a real problem (we could in principle re-align the events and get rid of it) and live with it. Unfortunately, if we want to handle properly the superposed events, we have to estimate and compensate the sampling jitter as will soon become clear.

When we first published our method [Pou02]_ we dealt with this jitter problem by using `Nyquist theorem <http://en.wikipedia.org/wiki/Nyquist%E2%80%93Shannon_sampling_theorem>`_ that tells us that if our data were properly sampled |---| with a sampling frequency larger than twice the low-pass cutoff frequency of our acquisition filter |---| we can reconstruct *exactly the data in-between our sampled points* by convolving the sampled data with a ``sinc`` function. We therefore went on, over sampling the data numerically, before shifting our individual events in order to align them on their cluster centre. This approach has several shortcomings: i) the support of the ``sinc`` is infinite but we are dealing with finite (in time) data and are therefore doing an approximate reconstruction; ii) computing the (approximate) interpolated values takes time. Luckily, recoding our procedure into Python led us to finally "see the light" |---| others [Pil13]_ followed a similar path before us. We can indeed solve our problem much more efficiently, without using the ``sinc`` function.

Formally if we write :math:`g(t)`, the observed waveform of an event within one of our cuts (the time *t* runs from -1 ms to +2 ms in our examples), and :math:`f(t)`, the underlying waveform |---| we are considering an event that is not a superposition and we write things for a single recording site to keep notations lighter, the generalisation to several recording sites is straightforward |---| we have:

.. math::
   :label: jitter1

   g(t) = f(t+\delta) + Z(t) \, ,

where :math:`\delta` is the jitter we want to estimate and :math:`Z(t)` is a stationary and centred Gaussian process (:math:`E(Z(t))=0` and :math:`\mathrm{Var}\left(Z(t)\right) = \sigma^2_Z`). Our approach seems to simplify considerably the estimation problem when compared to [Pil13]_. A second order Taylor expansion is used in our case, leading to:

.. math::
   :label: jitter2

   g(t) \approx f(t) + \delta f'(t) + \delta^2/2 \, f''(t) + Z(t) \, .
 
If we assume that :math:`\delta` is the realisation of a random variable :math:`\Delta` with a null expectation, :math:`\mathrm{E}(\Delta)=0` |---| that's a reasonable assumption given the origins of the jitter |---|  and finite variance, :math:`\sigma^2_{\Delta}`, then:

.. math::
   :label: jitter3

   \mathrm{E}\left(g(t)\right) \approx f(t)  + \sigma^2_{\Delta}/2 \, f''(t) \, .

In other words, to the first order in :math:`\delta` (*i.e.*, setting :math:`\sigma^2_{\Delta}` to 0), the expected value of the event equals the underlying waveform. Sticking to the first order we get for the variance:

.. math::
   :label: jitter4

   \mathrm{Var}\left(g(t)\right) = \mathrm{E}\left[\left(g(t)-f(t)\right)^2\right] \approx  \sigma^2_{\Delta} \, f'(t)^2 + \sigma^2_Z \, .

Implying that the square root of the events variance minus the noise variance should be proportional to their absolute derivative; this explains why the MAD (a robust estimate of the standard deviation) peaks on the rising phase of the cluster centre (Fig. :ref:`FirstTwoClusters`, top right) since that's where the time derivative is the largest.

Equation (:ref:`jitter3`) tells us that our cluster centres estimated as point-wise median are likely to be "good" (in other words their error should be dominated by sampling variance, not by bias). Using the same argument, we can get first an estimate of the time derivative of the raw data by using the central difference (divided by two), then we can make cuts at the same locations and in exactly the same way as our original cuts and compute cluster specific point-wise medians giving us reasonable estimates of the time derivatives of the cluster centres (the :math:`f'(t)` above). We can iterate this procedure one step further to get estimates of the second derivatives of the cluster centres (the :math:`f''(t)` above).

We now have the required elements to go back to our jitter (:math:`\delta`) estimation problem using Eq. (:ref:`jitter2`). We don't have :math:`g(t)`, :math:`f(t)`, :math:`f'(t)` or :math:`f''(t)` directly but only sampled versions of those, that is: :math:`\left[g_i=g(t_i)\right]_{i = t_1,\ldots,t_w}`, :math:`\left[f_i=f(t_i)\right]_{i=t_1,\ldots,t_w}` and :math:`\left[f'_i=f'(t_i)\right]_{i=t_1,\ldots,t_w}` where :math:`w` is the width of one of our cuts (45 sampling points). Starting with the first order in :math:`\delta`, we can get an estimate :math:`\tilde{\delta}` of :math:`\delta` by minimising the residual sum of squares (RSS) criterion:

.. math::
   :label: jitter5

    \tilde{\delta} = \arg \min_{\delta} \sum_i \left(g_i - f_i - \delta \, f_i'\right)^2 \, .
  
Since the :math:`(f_i)` and :math:`(f_i')` are known, we are just solving a classical linear regression problem whose solution is:

.. math::
   :label: jitter6

    \tilde{\delta} = \frac{\sum_i (g_i - f_i) \,  f_i'}{\sum_i f_i'^2} \, .

We could take the noise auto-correlation (that we can estimate) into account, but it turns out to be not worth it (the precision gain is not really offsetting the computational cost). 

We now solve the second order optimisation problem:

.. math::
   :label: jitter7

    \hat{\delta} = \arg \min_{\delta} \sum_i \left(g_i - f_i - \delta \, f_i' - \delta^2/2 \, f_i'' \right)^2 \, .

Since the latter does not admit (in general) a closed form solution, we perform a single `Newton-Raphson <http://en.wikipedia.org/wiki/Newton-Raphson>`_ step, starting from :math:`\tilde{\delta}` to get :math:`\hat{\delta}`. Only a *single* Newton-Raphson step is used because there is not much to be gained by refining the solution of an optimisation problem (Eq. :ref:`jitter7`) that only provides an approximate solution to the problem we are really interested in |---| which would be written here: :math:`\hat{\delta} = \arg \min_{\delta} \int \left(g(t)-f(t+\delta)\right)^2 dt` |---| the main error is likely to arise from the second order approximation of the latter |---| this point is clearly made in an other context, predictor-corrector method for ordinary differential equation, by Acton in [Act70]_ on pp. 133-134. 

Figure :ref:`JitterCancellationIllustrated` illustrates jitter estimation and cancellation at work. The left column shows one of the events attributed to cluster 1 (black, :math:`g(t)` in our previous discussion) together with the cluster centre estimate (blue, :math:`f(t)` in our previous discussion) and the difference of the two (red,  :math:`g(t)-f(t)` in our previous discussion). The right column shows again the event (black) with the *aligned* centre (blue, :math:`f(t) + \hat{\delta} \, f'(t) + \hat{\delta}^2/2 \, f'^2(t)` in the previous discussion) and the difference of the two (red).

.. figure:: Fig6.png
   :scale: 60%
   :figclass: hbt

   Left: event 50 of cluster 1 (black), centre of cluster 1 (blue), difference of the 2 (red). Right: event 50 of cluster 1 (black), *aligned* centre of cluster 1 (blue), difference of the 2 (red) :label:`JitterCancellationIllustrated`.

.. _peeling:

Spikes "peeling"
^^^^^^^^^^^^^^^^

We have almost reached the end of our journey. The clustering step gave us a catalogue of waveforms: the cluster centre, its first and second derivative for each of the :math:`K` neurons / clusters on each site. We now go back to the raw data and for each detected event we do:

1. Compute the squared Euclidean norm of event (over the 4 cuts corresponding to the 4 electrodes) to get :math:`R^2`.
2. For each of the :math:`K` neurons, align the centre's waveform on the event (as described in the previous section) and subtract it from the event. Compute the squared norm of this residual to get :math:`R_j^2` where :math:`j=1,\ldots,K`.
3. Find :math:`\hat{j} =\arg \min_j R_j^2` and if :math:`R_{\hat{j}}^2 < R^2` then:

   * Keep the jitter corrected time for :math:`\hat{j}` in the list of spikes and keep :math:`\hat{j}` as the neuron of origin.
   * Subtract the :math:`\hat{j}`-th aligned centre from the raw data

   otherwise *tag the event as unclassified* and don't perform any subtraction.

Once every detected event has been examined, we are left with a "new" version of the raw data from which the aligned "best" centre waveforms have been subtracted (only when doing so was reducing the sum of squares of the amplitudes over the cuts). For the event illustrated in Fig. :ref:`JitterCancellationIllustrated` we go from the black trace on the left column to the red trace on the right column. It is clear that for this "peeling procedure" to work we have to cancel the jitter otherwise we would be going from the black trace on the left column to the red trace *on the same column* (where what remains as a peak amplitude similar to what we started with!). 

We then iterate the procedure, taking the "new" raw data as if they were original data, detecting events as on the raw data, etc. We do that until we do not find anymore events for which the proposed subtraction is accepted; that is until we are only left with unclassified events. The first two iterations of this procedure are illustrated on figure :ref:`PeelingIllustrated`. See how the superposed event in the middle of the trace (left column) is nicely resolved into its two components. 

.. figure:: Fig7.png
   :align: center
   :scale: 25%
   :figclass: w

   Illustration the "peeling" procedure. Left: raw data (black) and first prediction (red); middle: previous raw data minus previous prediction (black) and new prediction (red); right: what's left (no more waveforms corresponding to the catalogue's content). The small spike left on the right (clearly visible in the middle on the four sites) does not belong to any neuron of the catalogue because the events used to built the latter where detected as local maxima (and we would need to detect local minima to catch events like the one we see here) :label:`PeelingIllustrated`.

Conclusions
-----------

Recoding our procedure from R to Python turned out to be easy (and an excellent way to learn Python for the first author). The efficient memory management provided by ``numpy`` for large arrays turns out to be very attractive. The "idiosyncrasies" of ``matplotlib`` (*e.g.*, linewidth abbreviation is ``lw`` in Matplotlib and
``lwd`` in R, color abbreviation is ``c`` in Matplotlib and in R is ``col``, etc) turn out to be the longest to digest |---| for an R user |---|, but once they are mastered, IPython provides an excellent environment for interactive sorting. We are clearly going to carry out the subsequent developments of our methods |---| starting by porting our C code dealing with more sophisticated data generation models [Pou04]_ and [Del06]_ within the Python ecosystem.

More fundamentally, the new jitter estimation and cancellation procedure we introduced is deceptively simple |---| similar to the method of [Pil13]_ but much simpler; to be fair, these authors also considered a possible amplitude and duration variability of the spikes generated by a given neuron. Our method is in fact, we think, an important step forward since it allows electrophysiologists to process superposed events systematically and *efficiently*. And, in our view, without superposed events processing there is no trustworthy spike sorting. 

.. Customised LaTeX packages
.. -------------------------

.. Please avoid using this feature, unless agreed upon with the
.. proceedings editors.

.. ::

..   .. latex::
..      :usepackage: somepackage

..      Some custom LaTeX source here.

Acknowledgments
---------------
This work has been supported by the ANR JCJC project ‚ÄúSynchNeuro‚Äù.

References
----------
.. [Act70] F. S. Acton. *Numerical Methods That Work*,
	   Harper & Row, 1970.
.. [Cha07] A. Chaffiol. *√âtude de la repr√©sentation des odeurs dans le lobe antennaire de Periplaneta americana*,
	   PhD Thesis, Universit√© Paris XIII (in French), 2007.
.. [Che05] M. I. Chelaru and M. S. Jog. *Spike source localization with tetrodes*,
	   J. Neurosci. Methods, 142(2):305-315, 2005.
.. [Del06] M. Delescluse and C. Pouzat. *Efficient spike-sorting of multi-state neurons using inter-spike intervals information*,
	   J. Neurosci. Methods, 150(1):16-29, 2006.
.. [Del12] M. Delescluse, R. Franconville, S. Joucla, T. Lieury and C. Pouzat. *Making neurophysiological data analysis reproducible. Why and how?*,
	   Journal of Physiology (Paris), 106(3-4):159-170, 2012
.. [Ein12] G. T. Einevoll, F. Franke, E. Hagen, C. Pouzat and K. D. Harris. *Towards reliable spike-train recordings from thousands of neurons
	with multielectrodes*,
	Current Opinion in Neurobiology, 22(1):11-17, 2012. 
.. [Lei99] F. Leisch. *Bagged clustering*,
	   TR 51 SFB Adaptive Information Systems and Modelling in Economics and Management. Available at: `<http://epub.wu.ac.at/id/eprint/1272>`_.
.. [McG85] K. C. McGill, K. L. Cummins and L. J. Dorfman. *Automatic decomposition of the clinical electromyogram*,
	   IEEE Trans. Biomed. Eng.,  32(7):470-477, July 1985.
.. [Pil13] J. W. Pillow, J. Shlens, E. J. Chichilnisky and E. P. Simoncelli. *A Model-Based Spike Sorting Algorithm for Removing Correlation Artifacts in Multi-Neuron Recordings*,
	   PLOS One, 8:e62123, May 2013.
.. [Pou02] C. Pouzat, O. Mazor and G. Laurent. *Using noise signature to optimize spike-sorting and to assess neuronal classification quality*,
	   J. Neurosci. Methods, 122(1):43-57, 2002.
.. [Pou04] C. Pouzat, M. Delescluse, P. Viot and J. Diebolt. *Improved spike-sorting by modeling firing statistics and burst-dependent spike amplitude attenuation: a Markov chain Monte Carlo approach*,
	   J. Neurophys., 91(6):2910-2928, 2004.
.. [Sho03] S. Shoham, M. R. Fellows and R. A. Normann. *Robust, automatic spike sorting using mixtures of multivariate t-distributions*,
	   J. Neurosci. Methods, 127(2):111-122, 2003.
.. [Sto14] V. Stodden, F. Leisch and R. Peng. *Implementing Reproducible Research*,
	   Chapman & Hall/CRC The R Series, 2014.

