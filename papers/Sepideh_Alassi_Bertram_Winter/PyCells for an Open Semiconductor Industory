:author: Sepideh Alassi
:email: sepideh.alassi@iis.fraunhofer.de
:institution: Fraunhofer IIS

:author: Bertram Winter
:email: Bertram.Winter@ams.com
:institution: ams AG


------------------------------------------------
PyCells for an Open Semiconductor Industory
------------------------------------------------

.. class:: abstract

	In modern semiconductor industory, automatic generation of parameterized and recurring layout structures plays an important role, and should be present as a feature in Electronic Desin Automation (EDA)-tools.
	
	Currently these layout generators are developed with a proprietary programming language SKILL, and can be used with a specific EDA-tool, Cadence. Therefore the development of the layout generators that can be used in all kinds of EDA-tools which suuport openaccess database is in a high demand.
	
	In this project we have developed these layout generators, PyCells, with Python using Python API library for all transistors, resistors, and capacitors of ams technologies, and have not only preserved all the features of a copmprehensive layout generator, but also enhanced the compuational performance.
	
	The resulting PyCells are verified thoroughly with respect to accuracy and computation time with different EDA-tools, and have extra interactive features such as auto-abutment and stretching.
   
.. class:: keywords

   PyCells, Semiconductor, OpenAccess

Introduction
------------

Twelve hundred years ago  |---| in a galaxy just across the hill...

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vestibulum sapien
tortor, bibendum et pretium molestie, dapibus ac ante. Nam odio orci, interdum
sit amet placerat non, molestie sed dui. Pellentesque eu quam ac mauris
tristique sodales. Fusce sodales laoreet nulla, id pellentesque risus convallis
eget. Nam id ante gravida justo eleifend semper vel ut nisi. Phasellus
adipiscing risus quis dui facilisis fermentum. Duis quis sodales neque. Aliquam
ut tellus dolor. Etiam ac elit nec risus lobortis tempus id nec erat. Morbi eu
purus enim. Integer et velit vitae arcu interdum aliquet at eget purus. Integer
quis nisi neque. Morbi ac odio et leo dignissim sodales. Pellentesque nec nibh
nulla. Donec faucibus purus leo. Nullam vel lorem eget enim blandit ultrices.
Ut urna lacus, scelerisque nec pellentesque quis, laoreet eu magna. Quisque ac
justo vitae odio tincidunt tempus at vitae tortor.

Development
------------

OpenAceess has been established as standard for storing design data in the semiconductor industry and builds the foundation for interoperability of EDA-tools. OpenAccess is file based database and manage the logical design data (schematics) as well as the artwork data for manufacturing (layout). The reference implementation for accessing design data within the database is written in C++. The company Ciranova (now acquired by Synopsys) developed a Python wrapper for the OpenAccess C++ class library with the goal to access and modify design data within Python. Additionally they provide an integrated development environment, which enables interactive development and debugging of Python code, while the effects on the design data are shown directly in a separated window.

In our development we made use of this Python API for OpenAceess to write Python scripts, which generate recurring layout structures based on a given set of parameters. Usually these recurring structures are primitive devices used in integrated circuit design, like resistors, capacitors and transistors. The electrical properties of these devices (resistance, capacitance and e. g. transistor transconductance) are brought down to geometric dimensions (e. g. width and length) which serve as parameters for the Python scripts. The object oriented nature of Python fits very well for this task as shown in the following example:

A typical CMOS semiconductor process offers n-channel and p-channel transistors. Each of these transistor types can have multiple voltage ratings (e. g. 5V, 20V, 50V 120V), which will then results in different layout structures. General speaking each transistor has a similar gate, source and drain structure but different doping concentrations for the implant regions of the semiconductor and different protection structures. Therefore we created a set of base classes in Python from which the more specialized transistors inherit common structures, while adding only structures dedicated to this type of transistor. This approach reduces duplicate code and makes maintaining the scripts more intuitive when the number of devices gets large. Finally the Python scripts are compiled to byte-code and stored inside the OpenAccess library. A plugin of the OpenAccess database takes care to load the correct script when a parameter of the corresponding device is touched.

 
Stretching
----------

Besides the basic feature, of specifying parameters for recurring structures, the Python API offers also more enhanced interactions with the EDA-tool. One of these is stretching. Stretching allows to change parameters of an instance interactively. This helps the engineer to fit instances of an analog design into the available space, without affecting the electrical properties of the instance. For example the capacitance value of a capacitor depends to a large extend on its area. Therefore the shape can be varied while maintaining a constant area. For simplicity the relationship is illustrated for a rectangular capacitor in figure :ref:`capfig`:

.. math::
   :label: capequ

   C \propto W \cdot L
   
.. figure:: stretch_cap.pdf
   :scale: 80%
   :align: center
   
   Stretching of a capacitor by changing L and W ratio, but keeping its area constant. :label:`capfig`


The electrical properties of resistors and transistors are proportional to the ratio of length and width:

.. math::
   :label: resequ

   R \propto \frac{L}{W}
   
.. math::
   :label: tranequ

   g_m \propto \frac{W}{L}
   
Therefore one can not simply fit them into a given shape, without affecting the behaviour of the design. One option is to allow the resistors to have bends (shown in figure :ref:`resfig`) or change the number of fingers for transistors (see figure :ref:`transfig`).
      
.. figure:: stretch_res.pdf
   :scale: 80%
   :align: center
   
   Stretching of a resistor by bending the device in a snake structure, but keeping length and width constant. :label:`resfig`
   
   
.. figure:: stretch_mos.pdf
   :scale: 80%
   :align: center
   
   Stretching of a transistor by increasing the number of fingers, but keeping the gate to source/drain edge constant. :label:`transfig`
   
   
All these features can be realized by making the PyCells stretchable. PyCells are made stretchable by pre-defined properties stored in the OpenAccess database. The stretch handles are defined within the Python source code. The stretch handles have to be associated to a layout shape and parameter. Stretching can be limited in horizontal or vertical direction. Also minimal and maximal limits, as well as a snap resolution can be specified. An example of a stretch handle definition is shown:

.. code-block:: python
   
   stretchHandle( 
       name = 'width_handle_left',
       shape = poly1GateShape,
	   parameter = 'wtot',
	   location = CENTER_LEFT,
	   direction = EAST_WEST,
	   stretchType = 'relative',
	   minVal = 0.4,
	   maxVal = 10000.0
   )

The layout tool displays then the stretch handles as small diamonds, which can be dragged by the engineer graphically to change the parameter value using the mouse. When releasing the stretch handle, the Python code is automatically invoked and the layout structure is adapted according to the new value of the parameter.


Abutment
--------

Another advanced feature is auto-abutment. Abutment is used to make the layout more area efficient. When placing two instances next to each other, the layout can be adapted in a way, that common structures are shared between the instances. This minimizes the layout area and two instances appear to be merged. Such as stretching, auto-abutment is defined by additional properties associated with shapes in the OpenAccess database. In Python abutment can be defined for a shape by using the autoAbutment() function: 
	
.. code-block:: python

    autoAbutment(
        shape = drain,
        pinSize = self.w,
        directions = [WEST],
        abutClass = 'mos_drain',
        abut2PinEqual = [{'spacing': 0.0},
            {'diffLeftStyle': 'DiffHalf'},
            {'diffLeftStyle': 'DiffHalf'}],
        abut2PinBigger = [{'spacing': 0.0},
            {'diffLeftStyle': 'DiffEdgeAbut'},
            {'diffLeftStyle': 'DiffEdgeAbut'}],
        abut3PinBigger = [{'spacing': 0.0},
            {'diffLeftStyle': 'ContactEdgeAbut2'},
            {'diffLeftStyle': 'ContactEdgeAbut2'}],
        abut3PinEqual = [{'spacing': 0.0},
            {'diffLeftStyle': 'DiffAbut'},
            {'diffLeftStyle': 'ContactEdgeAbut2'}],
        abut2PinSmaller = [{'spacing': 0.0},
            {'diffLeftStyle': 'DiffEdgeAbut'},
            {'diffLeftStyle': 'DiffEdgeAbut'}],
        abut3PinSmaller = [{'spacing': 0.0},
            {'diffLeftStyle': 'DiffEdgeAbut'},
            {'diffLeftStyle': 'DiffEdgeAbut'}],
        noAbut = [{'spacing': 0.4 }]
    )
	
This function provides a variety of parameters to define which instances are compatible for abutment. Only instances that have common layout structures can be merged. Furthermore, there are several function parameters to specify different types of abutment, for example what will happen if instances have common structures but are in different size. It is also important to take logical information of the design into account, as it is only allowed to merge structures which are logical connected (i. e. having the same net). The resulting layout can be further reduced, when the two instances are the only ones connected to the net. In this case structures between the two instance that would allow to connect to the net can be omitted (see figure :ref:`abutfig` for reference). 

.. figure:: abut_mos.pdf
	   :scale: 80%
	   :align: center
   
	   Abutment of two transistors: a) no abutment, as spacing between transistors is too large b) transistors abutted, but leave source/drain pin to connect to another instance c) transistors abutted, no connection to source/drain needed :label:`abutfig` 

When a layout engineer wants to abut two transistors, he drags one instance and places it in a way, that the drain contacts overlap. Then the abutment feature of the PyCell is triggered and the two instances are merged. If one instances is moved away again, each instance get its initial structure.

Verification:
--------------

The last but the most important part of the project is verifying the PyCells. We have considered four processes in order to verify the accuracy of PyCells: Design Rule Check (DRC), Layout Versus Schematic (LVS), Schematic Driven Layout (SDL), and database Comparison (DBCOMP).

	Design Rule Check (DRC):
	--------------------------
	The semiconductor manfacturers define a set of design rules for every technology that the layout of every design must comply with. Therefore all the layouts with various parameters which are generated by PyCells are checked for design rule violances in order to ensure the accuracy of them. A DRC verification software checks these layouts and highlights the violations. 
	
	Layout versus Schematic (LVS):
	------------------------------
	The layout of a design should match the schematic of it with respect to type and number of devices, connections, as well as the topogical parameters. In this verification process, we ensure that the layout of a sample design which is generated by PyCells matches perfectly with the schematic of the design. The LVS tool compares the layout and schematic of a design by extracting the netlists, according to design rules defined by semiconductor manfacturer, of layout and schematic in which the devices in design and their connections as well as topological parameters such as area, perimeter, etc are listed. 
	
	Schematic Driven Layout (SDL) :
	--------------------------------
	PyCell codes must include the definition of pins regarding type of connections, weak connection (by polysilicon) or strong connection (by metal), and definition of shapes that require exteranl connections. Having types of connections implemented in PyCells, the SDL Navigator tool can get the schematic of a sample design and generate the layout of it by calling PyCells with respective parameters. After generation of the layout, SDL Navigator checks the connectivity features.
	
	Database Compararison (DBCOMP):
	----------------------------
	The last verification step is to substantiate the aim of project, generating layouts with Python (PyCells) exactly the same as the ones generated with SKILL (PCells). This verification process is in GDSII level and is done with help of a regression test, in which in a layout the PCells and PyCells of identical devices are instanced with a set of parameters, and the layouts are compared to be congruent.
	
	

Conclusion
------------

Twelve hundred years ago  |---| in a galaxy just across the hill...

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vestibulum sapien
tortor, bibendum et pretium molestie, dapibus ac ante. Nam odio orci, interdum
sit amet placerat non, molestie sed dui. Pellentesque eu quam ac mauris
tristique sodales. Fusce sodales laoreet nulla, id pellentesque risus convallis
eget. Nam id ante gravida justo eleifend semper vel ut nisi. Phasellus
adipiscing risus quis dui facilisis fermentum. Duis quis sodales neque. Aliquam
ut tellus dolor. Etiam ac elit nec risus lobortis tempus id nec erat. Morbi eu
purus enim. Integer et velit vitae arcu interdum aliquet at eget purus. Integer
quis nisi neque. Morbi ac odio et leo dignissim sodales. Pellentesque nec nibh
nulla. Donec faucibus purus leo. Nullam vel lorem eget enim blandit ultrices.
Ut urna lacus, scelerisque nec pellentesque quis, laoreet eu magna. Quisque ac
justo vitae odio tincidunt tempus at vitae tortor.


References
----------
.. [OpenAccess] What is OpenAccess?
        https://www.si2.org/?page=69
.. [PyCell] Synopsys PyCell Studio
		https://www.synopsys.com/
